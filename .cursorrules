# .cursorrules
# Project: Next.js App Router SaaS (BFF + HttpOnly JWT + Azure APIM)
# Goal: Keep token server-only, centralize backend calls through BFF, use TanStack Query v5 for client data.

You are working in a Next.js App Router project using a Backend-For-Frontend (BFF) layer.
The backend is provided by another team (C#) and is accessed through Azure API Management (APIM) with a subscription key.
Authentication uses JWT returned by /users/api/auth/login and stored in HttpOnly cookies.

Follow these rules strictly.

──────────────────────────────────────────────────────────────────────────────
GENERAL PRINCIPLES
──────────────────────────────────────────────────────────────────────────────
- NEVER expose access tokens to the browser (no localStorage/sessionStorage, no returning tokens to client).
- All calls to the C# backend MUST go through the BFF API routes under /app/api/**.
- Centralize forwarding logic in src/lib/bff/forward.ts.
- Always attach APIM subscription key server-side.
- Prefer small, explicit modules: DTOs/mappers, routes, client components separated.

──────────────────────────────────────────────────────────────────────────────
ENVIRONMENT VARIABLES
──────────────────────────────────────────────────────────────────────────────
- Use .env.local for:
  - BFF_API_BASE=https://devwtgprintapimgmt.azure-api.net
  - APIM_SUBSCRIPTION_KEY=...
- Never hardcode secrets (subscription keys, client secrets) in code.

──────────────────────────────────────────────────────────────────────────────
AUTH & COOKIES
──────────────────────────────────────────────────────────────────────────────
- Store token + refreshToken in HttpOnly cookies via src/lib/bff/authCookies.ts.
- Server components and BFF routes must read cookies using await cookies() (Next dynamic API).
- /api/auth/login:
  - forwards to /users/api/auth/login via forwardToBackend with requireAuth:false
  - maps response to DTO
  - stores cookies
  - returns only safe info (ok, userId, message)
- /api/auth/logout:
  - clears cookies and returns { ok:true }
  - optionally implement GET for manual browser testing.
- /api/auth/me:
  - returns minimal status: { hasToken: boolean, userId?: string|null } when needed for bootstrapping.

Token lifetime/invalid token handling:
- In forwardToBackend: if backend responds 401, call clearAuthCookies().
- After 401 on the client, redirect to /login.

──────────────────────────────────────────────────────────────────────────────
BFF FORWARDING RULES (src/lib/bff/forward.ts)
──────────────────────────────────────────────────────────────────────────────
- Always build target URL with:
  - base from env (BFF_API_BASE)
  - backendPath (e.g., /users/api/management/users)
  - preserve querystring from incoming request
- Always set headers:
  - accept: application/json
  - content-type: passthrough if provided
  - Ocp-Apim-Subscription-Key from APIM_SUBSCRIPTION_KEY env
  - Authorization: Bearer <token> if token exists
- requireAuth defaults to true for protected routes; explicitly set requireAuth:false for login or public endpoints.
- Response passthrough:
  - return exact status + body
  - preserve content-type from backend.

Never call the backend directly from client components. Always go through /api/* BFF routes.

──────────────────────────────────────────────────────────────────────────────
NEXT.JS FILE CONVENTIONS (IMPORTANT)
──────────────────────────────────────────────────────────────────────────────
- middleware.ts is deprecated in this Next version. Use:
  - src/proxy.ts with export function proxy(req)
  - export const config = { matcher: [...] }
- App Router pages: searchParams may be Promise. Use:
  - export default async function Page({ searchParams }: { searchParams: Promise<...> })
  - const sp = await searchParams
- Prefer RSC for shells and layout; put interactive logic in "use client" components.

──────────────────────────────────────────────────────────────────────────────
API ROUTE DESIGN (app/api/**)
──────────────────────────────────────────────────────────────────────────────
- Create a BFF route mirroring backend capability:
  - GET/POST/PUT on /api/management/users -> forwardToBackend('/users/api/management/users')
  - /api/management/users/[userId] supports:
    - GET -> forwardToBackend(`/users/api/management/users/${userId}`)
    - DELETE -> forwardToBackend(`/users/api/management/users/${userId}`)
- API routes should be thin: validation + DTO mapping if needed; forwarding done by forward.ts.
- Return backend errors as-is (status + body) to allow UI to show messages.

──────────────────────────────────────────────────────────────────────────────
DTOs & MAPPERS (READABILITY)
──────────────────────────────────────────────────────────────────────────────
- Put DTOs + validators in src/lib/bff/dtos/*.ts.
- Use explicit types:
  - UserDto, UsersListResponseDto, CreateUserRequestDto, UpdateUserRequestDto, DeleteUserResponseDto.
- Provide lightweight runtime validators:
  - UsersMapper.assertUsersListResponse(data)
  - UsersMapper.assertUserDto(data)
  - UsersMapper.assertDeleteResponse(data)
- Do NOT introduce heavy libs (zod) unless explicitly requested.

──────────────────────────────────────────────────────────────────────────────
USER ACCOUNT CONTEXT (POST-LOGIN GLOBAL STATE) — STRICT
──────────────────────────────────────────────────────────────────────────────
- The app maintains a User Account Context derived from authentication:
  - domain, role, email, isActive, etc.
- Source of truth:
  - GET /users/api/management/users/{userId}
  - userId comes from /api/auth/me (token is server-only in HttpOnly cookies).
- Manage this context ONLY via TanStack Query (no React Context, no Redux/Zustand, no localStorage/sessionStorage).
- It is READ-ONLY and must be globally available for the entire app session.
- It must be cleared on logout and refetched on full page reload.

Query key (dedicated and stable):
- ['mgmt', 'current-user']

Bootstrap requirement (MANDATORY):
- Mount the current-user query at app bootstrap (main authenticated layout / global Providers).
- Bootstrap must ALWAYS be mounted and NEVER be conditional.

Dependency rule (VERY IMPORTANT):
- All business queries (users, groups, roles, permissions, etc.) MUST depend on current-user.
- Business queries MUST NOT execute until current-user is resolved (domain available).
- Never accept domain/role from user input or props.

──────────────────────────────────────────────────────────────────────────────
TANSTACK QUERY (v5) RULES — STRICT
──────────────────────────────────────────────────────────────────────────────
- Use TanStack Query v5 conventions:
  - keepPreviousData is NOT an option on useQuery.
  - Use placeholderData: keepPreviousData instead.

Query Key Convention (STRICT):
- All CRUD resource query keys MUST follow:
  ['mgmt', '<resource>', params]

Examples:
- ['mgmt', 'users', { pageSize, currentPage }]
- ['mgmt', 'roles', { pageSize, currentPage }]
- ['mgmt', 'customers', { pageSize, currentPage }]

Invalidation Rules (STRICT):
- Invalidate by resource prefix only:
  invalidateQueries({ queryKey: ['mgmt', '<resource>'] })

This invalidates all pages and filters for that resource and nothing else.

Forbidden query keys:
- ['management']
- ['mgmt']  (alone)
- ['users'] (alone)
- ['management-users']
- Any hardcoded or generic key

UseQuery loading indicators:
- isLoading = first load
- isFetching = background refresh or page changes

Client fetch:
- Use src/lib/http/clientFetch.ts for calling BFF endpoints from client components:
  - wraps fetch
  - if status 401 -> redirect to /login
- Client components must use clientFetch (not raw fetch) for BFF endpoints.

──────────────────────────────────────────────────────────────────────────────
USERS PAGE BEHAVIOR (LIST + SEARCH + PAGINATION)
──────────────────────────────────────────────────────────────────────────────
- Backend list endpoint:
  - GET /users/api/management/users?pageSize=X&currentPage=Y
  - Response: { pagination: { paginaCorrente, numeroTotalePagine, pageSize }, users: [...] }
- Search parameter q:
  - If backend has no search param, filter client-side only on current page.
- URL-driven pagination:
  - Update currentPage/pageSize via router.push with URLSearchParams.
- Debounced search:
  - Only reset currentPage to 1 when user changes search input.
  - Avoid resetting page on refresh/mount:
    - Skip first effect run (useRef) OR compare initial q/search.

──────────────────────────────────────────────────────────────────────────────
CRUD UX RULES (MODALS)
──────────────────────────────────────────────────────────────────────────────
- Create:
  - Open modal, submit POST /api/management/users
- Edit:
  - Same modal component, prefilled from row data
  - Submit PUT /api/management/users with payload:
    { userId, firstName, lastName, role, isActive }
  - Email/domain are not editable (not accepted in PUT payload).
- Delete:
  - Show confirmation popup before calling DELETE.
  - Call DELETE /api/management/users/[userId]
  - On success, invalidate users queries using:
    invalidateQueries({ queryKey: ['mgmt', 'users'] })

──────────────────────────────────────────────────────────────────────────────
STYLE & CODING STANDARDS
──────────────────────────────────────────────────────────────────────────────
- TypeScript: keep types explicit; no "any" unless unavoidable.
- Prefer small pure helper functions.
- Keep components readable; avoid deeply nested logic.
- No background promises, no unhandled rejections.
- When adding a new feature:
  1) DTO + mapper
  2) BFF route(s)
  3) Client UI with TanStack Query hooks
  4) Auth/401 behavior tested
  5) Ensure business queries depend on ['mgmt','current-user'] when domain/role is required

──────────────────────────────────────────────────────────────────────────────
SECURITY / SAFETY
──────────────────────────────────────────────────────────────────────────────
- Never log tokens or secrets.
- Never send Authorization headers from client; server attaches Bearer token.
- Never call the external backend directly from the browser.
- Keep subscription key only server-side.

END